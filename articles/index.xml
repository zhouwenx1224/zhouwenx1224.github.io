<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on </title>
    <link>/articles/</link>
    <description>Recent content in Articles on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="/articles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My LeetCode Diary - Day01 Arrays</title>
      <link>/articles/my-leetcode-diary-day01-arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day01-arrays/</guid>
      <description>Day1 Arrays - My LeetCode Diary int[] myNum = {10, 20, 30, 40}; //Loop Through an Array for (int i = 0; i &amp;lt; myNum.length; i++) { System.out.println(myNum[i]); } //OR for (int i : myNum) { System.out.println(i); } int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} }; System.out.println(myNumbers[1][2]); // Outputs 7 //Loop Through Multi-Dimensional Arrays for (int i = 0; i &amp;lt; myNumbers.length; ++i) { for(int j = 0; j &amp;lt; myNumbers[i].</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day02 Arrays</title>
      <link>/articles/my-leetcode-diary-day02-arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day02-arrays/</guid>
      <description>My LeetCode Diary - Day2 Arrays 977. Squares of a Sorted Array Link
Example 1:
Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2:
Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Both side after square the number, it both could be the largest number in the new array.
Thus, we use two pointers to index both side of the input arrays.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day03 LinkedList</title>
      <link>/articles/my-leetcode-diary-day03-linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day03-linkedlist/</guid>
      <description>My LeetCode Diary - Day3 LinkedList 203. Remove Linked List Elements Link
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // [1，1，1，1，1，1，1] while (head !</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day04 LinkedList</title>
      <link>/articles/my-leetcode-diary-day04-linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day04-linkedlist/</guid>
      <description>My LeetCode Diary - Day4 LinkedList 24. Swap Nodes in Pairs Link
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode cur = dummy; ListNode temp; //node3 ListNode first; //node1 ListNode second; //node2 while (cur.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day06 HashTable</title>
      <link>/articles/my-leetcode-diary-day06-hashtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day06-hashtable/</guid>
      <description>My LeetCode Diary - Day6 HashTable 242. Valid Anagram Link
class Solution { public boolean isAnagram(String s, String t) { int[] hash = new int[26]; for (int i=0;i&amp;lt;s.length();i++) { hash[s.charAt(i)-&amp;#39;a&amp;#39;]++; } for (int i=0; i&amp;lt;t.length(); i++){ hash[t.charAt(i)-&amp;#39;a&amp;#39;]--; } for (int num : hash){ if (num != 0) { return false; } } return true; } } 202. Happy Number Link
class Solution { public boolean isHappy(int n) { HashSet&amp;lt;Integer&amp;gt; seen = new HashSet&amp;lt;&amp;gt;(); while (n!</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day07 HashTable</title>
      <link>/articles/my-leetcode-diary-day07-hashtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day07-hashtable/</guid>
      <description>My LeetCode Diary - Day7 HashTable 454. 4Sum II Link
nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Iterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)} = {-1, 0, 0, 1} pairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day08 String</title>
      <link>/articles/my-leetcode-diary-day08-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day08-string/</guid>
      <description>My LeetCode Diary - Day8 String 344. Reverse String Link
class Solution { public void reverseString(char[] s) { char[] newArray = new char[s.length]; for (int i = 0; i &amp;lt; s.length; i++) { newArray[i] = s[s.length - i - 1]; } for (int i = 0; i &amp;lt; s.length; i++) { s[i] = newArray[i]; } } } 541. Reverse String II Link
class Solution { public String reverseStr(String s, int k) { StringBuilder sb = new StringBuilder(); while (s.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day09 String KMP</title>
      <link>/articles/my-leetcode-diary-day09-string-kmp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day09-string-kmp/</guid>
      <description>My LeetCode Diary - Day9 String KMP 28. Find the Index of the First Occurrence in a String Link
class Solution { public String reverseWords(String s) { String ans = &amp;#34;&amp;#34;; int start = -1, end = -1; for (int i = s.length() - 1; i&amp;gt;=0; i--){ if(s.charAt(i) != &amp;#39; &amp;#39; &amp;amp;&amp;amp; end == -1){ end = i; } else if(s.charAt(i) == &amp;#39; &amp;#39; &amp;amp;&amp;amp; end != -1){ start = i + 1; ans = ans + s.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day10 Stack&amp;Queue</title>
      <link>/articles/my-leetcode-diary-day10-stackqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day10-stackqueue/</guid>
      <description>My LeetCode Diary - Day10 Stack&amp;amp;Queue 232. Implement Queue using Stacks Link
class MyQueue { Stack&amp;lt;Integer&amp;gt; inStack; Stack&amp;lt;Integer&amp;gt; outStack; public MyQueue() { this.inStack = new Stack&amp;lt;&amp;gt;(); this.outStack = new Stack&amp;lt;&amp;gt;(); } public void push(int x) { while(!outStack.isEmpty()){ inStack.push(outStack.pop()); } inStack.push(x); while(!inStack.isEmpty()){ outStack.push(inStack.pop()); } } public int pop() { if(outStack.isEmpty()){ return -1; } return outStack.pop(); } public int peek() { if(outStack.isEmpty()){ return -1; } return outStack.peek(); } public boolean empty() { return outStack.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day11 Stack&amp;Queue</title>
      <link>/articles/my-leetcode-diary-day11-stackqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day11-stackqueue/</guid>
      <description>My LeetCode Diary - Day11 Stack&amp;amp;Queue 20. Valid Parentheses Link
class Solution { public boolean isValid(String s) { Deque&amp;lt;Character&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); char ch; for (int i = 0; i&amp;lt;s.length();i++){ ch = s.charAt(i); if (ch == &amp;#39;(&amp;#39;){ deque.push(&amp;#39;)&amp;#39;); } else if (ch == &amp;#39;{&amp;#39;) { deque.push(&amp;#39;}&amp;#39;); } else if (ch == &amp;#39;[&amp;#39;) { deque.push(&amp;#39;]&amp;#39;); } else if (deque.isEmpty() || deque.peek() != ch) { return false; } else { deque.pop(); } } return deque.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day12 Stack&amp;Queue</title>
      <link>/articles/my-leetcode-diary-day12-stackqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day12-stackqueue/</guid>
      <description>My LeetCode Diary - Day12 Stack&amp;amp;Queue 239. Sliding Window Maximum Link
class MyQueue { Deque&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); void poll(int val) { if (!deque.isEmpty() &amp;amp;&amp;amp; val == deque.peek()) { deque.poll(); } } void add(int val) { while (!deque.isEmpty() &amp;amp;&amp;amp; val &amp;gt; deque.getLast()){ deque.removeLast(); } deque.add(val); } int peek() { return deque.peek(); } } class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 1){ return nums; } int len = nums.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day14 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day14-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day14-binarytree/</guid>
      <description>My LeetCode Diary - Day14 BinaryTree 144. Binary Tree Preorder Traversal Link
class Solution { public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;(); preorder(root,result); return result; } public void preorder(TreeNode root, List&amp;lt;Integer&amp;gt; result) { if (root == null){ return; } result.add(root.val); preorder(root.left, result); preorder(root.right,result); } } class Solution { public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } stack.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day15 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day15-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day15-binarytree/</guid>
      <description>My LeetCode Diary - Day15 BinaryTree 102. Binary Tree Level Order Traversal Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; resList = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { checkFun(root); return resList; } public void checkFun(TreeNode node) { if (node == null) { return; } Queue&amp;lt;TreeNode&amp;gt; que = new LinkedList&amp;lt;TreeNode&amp;gt;(); que.offer(node); while(!que.isEmpty()) { List&amp;lt;Integer&amp;gt; itemList = new ArrayList&amp;lt;&amp;gt;(); int len = que.size(); while (len&amp;gt;0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left !</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day16 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day16-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day16-binarytree/</guid>
      <description>My LeetCode Diary - Day16 BinaryTree 104. Maximum Depth of Binary Tree Link
class solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; } } 111. Minimum Depth of Binary Tree Link
class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = minDepth(root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day17 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day17-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day17-binarytree/</guid>
      <description>My LeetCode Diary - Day16 BinaryTree 110. Balanced Binary Tree Link
class Solution { /** * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历 * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。 * 时间复杂度：O(n) */ public boolean isBalanced(TreeNode root) { if (root == null) { return true; } Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); TreeNode pre = null; while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } TreeNode inNode = stack.peek(); // 右结点为null或已经遍历过 if (inNode.right == null || inNode.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day18 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day18-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day18-binarytree/</guid>
      <description>My LeetCode Diary - Day18 BinaryTree 513. Find Bottom Left Tree Value Link
class Solution { public int findBottomLeftValue(TreeNode root) { Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.offer(root); while (!queue.isEmpty()){ root = queue.poll(); if (root.right != null) { queue.offer(root.right); } if (root.left != null) { queue.offer(root.left); } } return root.val; } } 112. Path Sum Link
class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) { return false; } targetSum -= root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day20 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day20-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day20-binarytree/</guid>
      <description>My LeetCode Diary - Day20 BinaryTree 654. Maximum Binary Tree Link
class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return constructMaximumBinaryTree1(nums, 0, nums.length); } public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) { if (rightIndex - leftIndex &amp;lt; 1) { return null; } if (rightIndex - leftIndex == 1) { return new TreeNode(nums[leftIndex]); } int maxIndex = leftIndex; int maxVal = nums[maxIndex]; for (int i = leftIndex + 1; i &amp;lt; rightIndex; i++) { if (nums[i] &amp;gt; maxVal){ maxVal = nums[i]; maxIndex = i; } } TreeNode root = new TreeNode(maxVal); root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day21 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day21-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day21-binarytree/</guid>
      <description>My LeetCode Diary - Day21 BinaryTree 530. Minimum Absolute Difference in BST Link
class Solution { TreeNode pre; int result = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { if(root==null)return 0; traversal(root); return result; } public void traversal(TreeNode root){ if(root==null)return; //左 traversal(root.left); //中 if(pre!=null){ result = Math.min(result,root.val-pre.val); } pre = root; //右 traversal(root.right); } } 501. Find Mode in Binary Search Tree Link
class Solution { public int[] findMode(TreeNode root) { TreeNode pre = null; Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); int maxCount = 0; int count = 0; TreeNode cur = root; while (cur !</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day22 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day22-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day22-binarytree/</guid>
      <description>My LeetCode Diary - Day22 BinaryTree 235. Lowest Common Ancestor of a Binary Search Tree Link
class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root.val &amp;gt; p.val &amp;amp;&amp;amp; root.val &amp;gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &amp;lt; p.val &amp;amp;&amp;amp; root.val &amp;lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; } } 701. Insert into a Binary Search Tree Link
class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) return new TreeNode(val); if (root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day23 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day23-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day23-binarytree/</guid>
      <description>My LeetCode Diary - Day23 BinaryTree 669. Trim a Binary Search Tree Link
class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if (root == null) { return null; } if (root.val &amp;lt; low) { return trimBST(root.right, low, high); } if (root.val &amp;gt; high) { return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; } 108. Convert Sorted Array to Binary Search Tree Link</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day24 BackTracking</title>
      <link>/articles/my-leetcode-diary-day24-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day24-backtracking/</guid>
      <description>My LeetCode Diary - Day24 BackTracking 77. Combinations Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;Integer&amp;gt; path = new LinkedList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { backTracking(n,k,1); return result; } void backTracking(int n, int k, int startIndex) { if (path.size() == k) { result.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = startIndex; i &amp;lt;= n - (k-path.size()) + 1; i++) { path.add(i); backTracking(n,k,i+1); path.removeLast(); } } } </description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day25 BackTracking</title>
      <link>/articles/my-leetcode-diary-day25-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day25-backtracking/</guid>
      <description>My LeetCode Diary - Day25 BackTracking 216. Combination Sum III Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;Integer&amp;gt; path = new LinkedList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) { backTracking(n,0,k,1); return result; } void backTracking(int n, int sum, int k, int startIndex) { if (path.size() == k) { if (sum == n) { result.add(new ArrayList&amp;lt;&amp;gt;(path)); } } if (sum &amp;gt; n) { return; } for (int i = startIndex; i &amp;lt;= 9; i++) { path.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day26 BackTracking</title>
      <link>/articles/my-leetcode-diary-day26-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day26-backtracking/</guid>
      <description>My LeetCode Diary - Day26 BackTracking 39. Combination Sum Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;Integer&amp;gt; path = new LinkedList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { backTracking(candidates, target, 0,0); return res; } void backTracking(int[] candidates, int target, int sum, int start) { if (sum == target) { res.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } if (sum &amp;gt; target) { return; } for (int i = start; i &amp;lt; candidates.length; i++) { path.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day27 BackTracking</title>
      <link>/articles/my-leetcode-diary-day27-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day27-backtracking/</guid>
      <description>My LeetCode Diary - Day27 BackTracking 93. Restore IP Addresses Link
class Solution { List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;String&amp;gt; path = new LinkedList&amp;lt;&amp;gt;(); public List&amp;lt;String&amp;gt; restoreIpAddresses(String s) { backTrack(s,0); return res; } void backTrack(String s, int index) { if (path.size() == 4 &amp;amp;&amp;amp; index == s.length()) { res.add(String.join(&amp;#34;.&amp;#34;,path)); } for (int i = index; i &amp;lt; s.length(); i++) { if (!isValid(s, index, i)) { continue; } if (path.size() &amp;gt;= 4) { break; } path.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day28 BackTracking</title>
      <link>/articles/my-leetcode-diary-day28-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day28-backtracking/</guid>
      <description>My LeetCode Diary - Day28 BackTracking 491. Non-decreasing Subsequences Link
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;Integer&amp;gt; path = new LinkedList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; findSubsequences(int[] nums) { backTrack(nums,0); return res; } void backTrack(int[] nums,int index) { if (path.size() &amp;gt; 1) { res.add(new ArrayList&amp;lt;&amp;gt;(path)); } HashMap&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = index; i &amp;lt; nums.length; i++) { if ( !path.isEmpty() &amp;amp;&amp;amp; nums[i] &amp;lt; path.getLast()) { continue; } if (map.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day30 BackTracking</title>
      <link>/articles/my-leetcode-diary-day30-greedy-algo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day30-greedy-algo/</guid>
      <description>My LeetCode Diary - Day30 Greedy Algo 455. Assign Cookies Link
class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; //考虑大胃口 int index = s.length - 1; for (int i = g.length -1 ;i &amp;gt;=0; i--) { if (index &amp;gt;= 0 &amp;amp;&amp;amp; g[i] &amp;lt;= s[index]){ index--; count++; } } return count; } } class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day32 Greedy Algo</title>
      <link>/articles/my-leetcode-diary-day32-greedy-algo-dab85eea719b4bf4822b3f27f1b0aa31/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day32-greedy-algo-dab85eea719b4bf4822b3f27f1b0aa31/</guid>
      <description>My LeetCode Diary - Day32 Greedy Algo 122. Best Time to Buy and Sell Stock II Link
class Solution { public int maxProfit(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; for (int i = 0; i &amp;lt; n;i++) { if (i == 0) { dp[i][0] = 0; dp[i][1] = -prices[i]; continue; } dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]); } return dp[n-1][0]; } } 55.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day34 Greedy Algo</title>
      <link>/articles/my-leetcode-diary-day34-greedy-algo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day34-greedy-algo/</guid>
      <description>My LeetCode Diary - Day34 Greedy Algo 1005. Maximize Sum Of Array After K Negations Link
class Solution { public int largestSumAfterKNegations(int[] A, int K) { if (A.length == 1) return k % 2 == 0 ? A[0] : -A[0]; Arrays.sort(A); int sum = 0; int idx = 0; for (int i = 0; i &amp;lt; K; i++) { if (i &amp;lt; A.length - 1 &amp;amp;&amp;amp; A[idx] &amp;lt; 0) { A[idx] = -A[idx]; if (A[idx] &amp;gt;= Math.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day35 Greedy Algo</title>
      <link>/articles/my-leetcode-diary-day35-greedy-algo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day35-greedy-algo/</guid>
      <description>My LeetCode Diary - Day35 Greedy Algo 860. Lemonade Change Link
class Solution { public boolean lemonadeChange(int[] bills) { int five = 0; int ten = 0; for (int i = 0; i &amp;lt; bills.length ; i++) { if (bills[i] == 5) { five++; } else if (bills[i] == 10) { five--; ten++; } else if (bills[i] == 20) { if (ten&amp;gt;0) { ten--; five--; } else{ five -=3; } } if (five &amp;lt; 0 || ten &amp;lt; 0) { return false; } } return true; } } 406.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day36 Greedy Algo</title>
      <link>/articles/my-leetcode-diary-day36-greedy-algo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day36-greedy-algo/</guid>
      <description>My LeetCode Diary - Day36 Greedy Algo 435. Non-overlapping Intervals Link
class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a,b)-&amp;gt; { return Integer.compare(a[0],b[0]); }); int remove = 0; int pre = intervals[0][1]; for(int i = 1; i &amp;lt; intervals.length; i++) { if(pre &amp;gt; intervals[i][0]) { remove++; pre = Math.min(pre, intervals[i][1]); } else pre = intervals[i][1]; } return remove; } } 763. Partition Labels Link
class Solution { public List&amp;lt;Integer&amp;gt; partitionLabels(String S) { List&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); int[] edge = new int[26]; char[] chars = S.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day38 Dynamic Programming</title>
      <link>/articles/my-leetcode-diary-day38-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day38-dynamic-programming/</guid>
      <description>My LeetCode Diary - Day38 Dynamic Programming 509. Fibonacci Number Link
class Solution { public int fib(int n) { if (n&amp;lt;=1) { return n; } int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &amp;lt;= n;i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } } 70. Climbing Stairs Link
class Solution { public int climbStairs(int n) { if (n&amp;lt;=1) { return n; } int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &amp;lt;= n;i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } } 746.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day39 Dynamic Programming</title>
      <link>/articles/my-leetcode-diary-day39-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day39-dynamic-programming/</guid>
      <description>My LeetCode Diary - Day39 Dynamic Programming 62. Unique Paths Link
class Solution { public static int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { dp[i][0] = 1; } for (int i = 0; i &amp;lt; n; i++) { dp[0][i] = 1; } for (int i = 1; i &amp;lt; m; i++) { for (int j = 1; j &amp;lt; n; j++) { dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } } 63.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day41 Dynamic Programming</title>
      <link>/articles/my-leetcode-diary-day41-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day41-dynamic-programming/</guid>
      <description>My LeetCode Diary - Day41 Dynamic Programming 343. Integer Break Link
class Solution { public int integerBreak(int n) { int[] dp = new int[n+1]; dp[2] = 1; for (int i = 3; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt; i; j++){ dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j])); } } return dp[n]; } } 96. Unique Binary Search Trees Link
class Solution { public int numTrees(int n) { int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &amp;lt;=n ; i++) { for (int j = 1; j &amp;lt;= i; j++) { dp[i] += dp[j-1] * dp[i-j]; } } return dp[n]; } } </description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day43 Dynamic Programming</title>
      <link>/articles/my-leetcode-diary-day43-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day43-dynamic-programming/</guid>
      <description>My LeetCode Diary - Day43 Dynamic Programming 1049. Last Stone Weight II Link
class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int s : stones) { sum += s; } int target = sum / 2; int[][] dp = new int[stones.length][target + 1]; for (int j = stones[0]; j &amp;lt;= target; j++) { dp[0][j] = stones[0]; } for (int i = 1; i &amp;lt; stones.length; i++) { for (int j = 1; j &amp;lt;= target; j++) { if (j &amp;gt;= stones[i]) { dp[i][j] = Math.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day44 Dynamic Programming</title>
      <link>/articles/my-leetcode-diary-day44-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day44-dynamic-programming/</guid>
      <description>My LeetCode Diary - Day44 Dynamic Programming 518. Coin Change II Link
class Solution { public int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; for (int i = 0; i &amp;lt; coins.length; i++) { for (int j = coins[i]; j &amp;lt;= amount; j++) { dp[j] += dp[j - coins[i]]; } } return dp[amount]; } } 377. Combination Sum IV Link
class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i &amp;lt;= target; i++) { for (int j = 0; j &amp;lt; nums.</description>
    </item>
    
  </channel>
</rss>
