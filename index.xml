<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 28 Mar 2023 20:20:12 -0500</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Smart Tracker</title>
      <link>/projects/smart_tracker/</link>
      <pubDate>Tue, 28 Mar 2023 20:20:12 -0500</pubDate>
      
      <guid>/projects/smart_tracker/</guid>
      <description>🫶 Smart Tracker ⭐ Architecture ⭐ Device ⭐ Functionalities Device addition and review module. The first person to add the device becomes the administrator. Other users need to be approved by the administrator before they can see the device information. Device positioning service reports data including (latitude and longitude, positioning mode, and reporting timestamp) using gcj02 coordinates globally. The device uses three positioning modes (LBS, GPS, WIFI). This positioning module directly connects to a ready-made product purchased from Taobao and used with a Raspberry Pi.</description>
    </item>
    
    <item>
      <title>Reggie Food Delivery System</title>
      <link>/projects/food/</link>
      <pubDate>Mon, 27 Feb 2023 20:20:12 -0500</pubDate>
      
      <guid>/projects/food/</guid>
      <description>Reggie Food Delivery System 🫶 Backend System 💡 Employee Management: Login, Logout Add Modify List Disable, Enable 💡 Category management: Add Modify List Delete 💡 Cuisine Management: Add Modify List Delete Stop sale, start sale 💡 Package Management: Add Modify List Delete Stop Sale, Start Sale 💡 Order details List Status operations ✂️ Mobile(Front) application Cell phone number login with Verification Code Personal Center Address Management Order History Browse dishes, packages Shopping Cart Add to cart Empty cart Place an order ✂️ Mobile(Front) and Management(Backend) Demo </description>
    </item>
    
    <item>
      <title>Math Braintrainer</title>
      <link>/projects/math-brain-trainer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/projects/math-brain-trainer/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day1 Arrays</title>
      <link>/articles/day1-arrays-my-leetcode-diary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/day1-arrays-my-leetcode-diary/</guid>
      <description>Day1 Arrays - My LeetCode Diary int[] myNum = {10, 20, 30, 40}; //Loop Through an Array for (int i = 0; i &amp;lt; myNum.length; i++) { System.out.println(myNum[i]); } //OR for (int i : myNum) { System.out.println(i); } int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} }; System.out.println(myNumbers[1][2]); // Outputs 7 //Loop Through Multi-Dimensional Arrays for (int i = 0; i &amp;lt; myNumbers.length; ++i) { for(int j = 0; j &amp;lt; myNumbers[i].</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day10 Stack&amp;Queue</title>
      <link>/articles/my-leetcode-diary-day10-stackqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day10-stackqueue/</guid>
      <description>My LeetCode Diary - Day10 Stack&amp;amp;Queue 232. Implement Queue using Stacks Link
class MyQueue { Stack&amp;lt;Integer&amp;gt; inStack; Stack&amp;lt;Integer&amp;gt; outStack; public MyQueue() { this.inStack = new Stack&amp;lt;&amp;gt;(); this.outStack = new Stack&amp;lt;&amp;gt;(); } public void push(int x) { while(!outStack.isEmpty()){ inStack.push(outStack.pop()); } inStack.push(x); while(!inStack.isEmpty()){ outStack.push(inStack.pop()); } } public int pop() { if(outStack.isEmpty()){ return -1; } return outStack.pop(); } public int peek() { if(outStack.isEmpty()){ return -1; } return outStack.peek(); } public boolean empty() { return outStack.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day11 Stack&amp;Queue</title>
      <link>/articles/my-leetcode-diary-day11-stackqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day11-stackqueue/</guid>
      <description>My LeetCode Diary - Day11 Stack&amp;amp;Queue 20. Valid Parentheses Link
class Solution { public boolean isValid(String s) { Deque&amp;lt;Character&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); char ch; for (int i = 0; i&amp;lt;s.length();i++){ ch = s.charAt(i); if (ch == &amp;#39;(&amp;#39;){ deque.push(&amp;#39;)&amp;#39;); } else if (ch == &amp;#39;{&amp;#39;) { deque.push(&amp;#39;}&amp;#39;); } else if (ch == &amp;#39;[&amp;#39;) { deque.push(&amp;#39;]&amp;#39;); } else if (deque.isEmpty() || deque.peek() != ch) { return false; } else { deque.pop(); } } return deque.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day12 Stack&amp;Queue</title>
      <link>/articles/my-leetcode-diary-day12-stackqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day12-stackqueue/</guid>
      <description>My LeetCode Diary - Day12 Stack&amp;amp;Queue 239. Sliding Window Maximum Link
class MyQueue { Deque&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); void poll(int val) { if (!deque.isEmpty() &amp;amp;&amp;amp; val == deque.peek()) { deque.poll(); } } void add(int val) { while (!deque.isEmpty() &amp;amp;&amp;amp; val &amp;gt; deque.getLast()){ deque.removeLast(); } deque.add(val); } int peek() { return deque.peek(); } } class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 1){ return nums; } int len = nums.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day14 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day14-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day14-binarytree/</guid>
      <description>My LeetCode Diary - Day14 BinaryTree 144. Binary Tree Preorder Traversal Link
class Solution { public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;(); preorder(root,result); return result; } public void preorder(TreeNode root, List&amp;lt;Integer&amp;gt; result) { if (root == null){ return; } result.add(root.val); preorder(root.left, result); preorder(root.right,result); } } class Solution { public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } stack.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day15 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day15-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day15-binarytree/</guid>
      <description>My LeetCode Diary - Day15 BinaryTree 102. Binary Tree Level Order Traversal Link
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; resList = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { checkFun(root); return resList; } public void checkFun(TreeNode node) { if (node == null) { return; } Queue&amp;lt;TreeNode&amp;gt; que = new LinkedList&amp;lt;TreeNode&amp;gt;(); que.offer(node); while(!que.isEmpty()) { List&amp;lt;Integer&amp;gt; itemList = new ArrayList&amp;lt;&amp;gt;(); int len = que.size(); while (len&amp;gt;0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left !</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day16 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day16-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day16-binarytree/</guid>
      <description>My LeetCode Diary - Day16 BinaryTree 104. Maximum Depth of Binary Tree Link
class solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; } } 111. Minimum Depth of Binary Tree Link
class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = minDepth(root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day17 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day17-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day17-binarytree/</guid>
      <description>My LeetCode Diary - Day16 BinaryTree 110. Balanced Binary Tree Link
class Solution { /** * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历 * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。 * 时间复杂度：O(n) */ public boolean isBalanced(TreeNode root) { if (root == null) { return true; } Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); TreeNode pre = null; while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } TreeNode inNode = stack.peek(); // 右结点为null或已经遍历过 if (inNode.right == null || inNode.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day18 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day18-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day18-binarytree/</guid>
      <description>My LeetCode Diary - Day18 BinaryTree 513. Find Bottom Left Tree Value Link
class Solution { public int findBottomLeftValue(TreeNode root) { Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.offer(root); while (!queue.isEmpty()){ root = queue.poll(); if (root.right != null) { queue.offer(root.right); } if (root.left != null) { queue.offer(root.left); } } return root.val; } } 112. Path Sum Link
class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) { return false; } targetSum -= root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day2 Arrays</title>
      <link>/articles/my-leetcode-diary-day2-arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day2-arrays/</guid>
      <description>My LeetCode Diary - Day2 Arrays 977. Squares of a Sorted Array Link
Example 1:
Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2:
Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Both side after square the number, it both could be the largest number in the new array.
Thus, we use two pointers to index both side of the input arrays.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day20 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day20-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day20-binarytree/</guid>
      <description>My LeetCode Diary - Day20 BinaryTree 654. Maximum Binary Tree Link
class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return constructMaximumBinaryTree1(nums, 0, nums.length); } public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) { if (rightIndex - leftIndex &amp;lt; 1) { return null; } if (rightIndex - leftIndex == 1) { return new TreeNode(nums[leftIndex]); } int maxIndex = leftIndex; int maxVal = nums[maxIndex]; for (int i = leftIndex + 1; i &amp;lt; rightIndex; i++) { if (nums[i] &amp;gt; maxVal){ maxVal = nums[i]; maxIndex = i; } } TreeNode root = new TreeNode(maxVal); root.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day21 BinaryTree</title>
      <link>/articles/my-leetcode-diary-day21-binarytree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day21-binarytree/</guid>
      <description>My LeetCode Diary - Day21 BinaryTree 530. Minimum Absolute Difference in BST Link
class Solution { TreeNode pre; int result = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { if(root==null)return 0; traversal(root); return result; } public void traversal(TreeNode root){ if(root==null)return; //左 traversal(root.left); //中 if(pre!=null){ result = Math.min(result,root.val-pre.val); } pre = root; //右 traversal(root.right); } } 501. Find Mode in Binary Search Tree Link
class Solution { public int[] findMode(TreeNode root) { TreeNode pre = null; Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); int maxCount = 0; int count = 0; TreeNode cur = root; while (cur !</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day3 LinkedList</title>
      <link>/articles/my-leetcode-diary-day3-linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day3-linkedlist/</guid>
      <description>My LeetCode Diary - Day3 LinkedList 203. Remove Linked List Elements Link
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // [1，1，1，1，1，1，1] while (head !</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day4 LinkedList</title>
      <link>/articles/my-leetcode-diary-day4-linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day4-linkedlist/</guid>
      <description>My LeetCode Diary - Day4 LinkedList 24. Swap Nodes in Pairs Link
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode cur = dummy; ListNode temp; //node3 ListNode first; //node1 ListNode second; //node2 while (cur.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day6 HashTable</title>
      <link>/articles/my-leetcode-diary-day6-hashtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day6-hashtable/</guid>
      <description>My LeetCode Diary - Day6 HashTable 242. Valid Anagram Link
class Solution { public boolean isAnagram(String s, String t) { int[] hash = new int[26]; for (int i=0;i&amp;lt;s.length();i++) { hash[s.charAt(i)-&amp;#39;a&amp;#39;]++; } for (int i=0; i&amp;lt;t.length(); i++){ hash[t.charAt(i)-&amp;#39;a&amp;#39;]--; } for (int num : hash){ if (num != 0) { return false; } } return true; } } 202. Happy Number Link
class Solution { public boolean isHappy(int n) { HashSet&amp;lt;Integer&amp;gt; seen = new HashSet&amp;lt;&amp;gt;(); while (n!</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day7 HashTable</title>
      <link>/articles/my-leetcode-diary-day7-hashtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day7-hashtable/</guid>
      <description>My LeetCode Diary - Day7 HashTable 454. 4Sum II Link
nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Iterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)} = {-1, 0, 0, 1} pairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day8 String</title>
      <link>/articles/my-leetcode-diary-day8-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day8-string/</guid>
      <description>My LeetCode Diary - Day8 String 344. Reverse String Link
class Solution { public void reverseString(char[] s) { char[] newArray = new char[s.length]; for (int i = 0; i &amp;lt; s.length; i++) { newArray[i] = s[s.length - i - 1]; } for (int i = 0; i &amp;lt; s.length; i++) { s[i] = newArray[i]; } } } 541. Reverse String II Link
class Solution { public String reverseStr(String s, int k) { StringBuilder sb = new StringBuilder(); while (s.</description>
    </item>
    
    <item>
      <title>My LeetCode Diary - Day9 String KMP</title>
      <link>/articles/my-leetcode-diary-day9-string-kmp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/articles/my-leetcode-diary-day9-string-kmp/</guid>
      <description>My LeetCode Diary - Day9 String KMP 28. Find the Index of the First Occurrence in a String Link
class Solution { public String reverseWords(String s) { String ans = &amp;#34;&amp;#34;; int start = -1, end = -1; for (int i = s.length() - 1; i&amp;gt;=0; i--){ if(s.charAt(i) != &amp;#39; &amp;#39; &amp;amp;&amp;amp; end == -1){ end = i; } else if(s.charAt(i) == &amp;#39; &amp;#39; &amp;amp;&amp;amp; end != -1){ start = i + 1; ans = ans + s.</description>
    </item>
    
  </channel>
</rss>
